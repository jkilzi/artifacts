{"version":3,"file":"workflow.cjs.js","sources":["../src/workflow.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Specification } from '@severlessworkflow/sdk-typescript';\nimport { dump } from 'js-yaml';\n\nimport { ASSESSMENT_WORKFLOW_TYPE } from './constants';\nimport { WorkflowCategory, WorkflowDefinition, WorkflowFormat } from './types';\n\nexport function fromWorkflowSource(content: string): WorkflowDefinition {\n  const parsed = Specification.Workflow.fromSource(content);\n  const workflow = parsed.sourceModel ?? parsed;\n  return removeProperty(workflow, 'normalize');\n}\n\nexport function toWorkflowString(\n  definition: WorkflowDefinition,\n  format: WorkflowFormat,\n): string {\n  switch (format) {\n    case 'json':\n      return toWorkflowJson(definition);\n    case 'yaml':\n      return toWorkflowYaml(definition);\n    default:\n      throw new Error(`Unsupported format ${format}`);\n  }\n}\n\nexport function toWorkflowJson(definition: WorkflowDefinition): string {\n  return JSON.stringify(definition, null, 2);\n}\n\nexport function toWorkflowYaml(definition: WorkflowDefinition): string {\n  return dump(definition);\n}\n\nexport function extractWorkflowFormatFromUri(uri: string): WorkflowFormat {\n  const match = RegExp(/\\.sw\\.(json|yaml|yml)$/).exec(uri);\n  if (match) {\n    if (match[1] === 'yml' || match[1] === 'yaml') {\n      return 'yaml';\n    }\n    if (match[1] === 'json') {\n      return 'json';\n    }\n  }\n  throw new Error(`Unsupported workflow format for uri ${uri}`);\n}\n\nexport function getWorkflowCategory(\n  definition: WorkflowDefinition | undefined,\n): WorkflowCategory {\n  if (definition === undefined) {\n    return WorkflowCategory.INFRASTRUCTURE;\n  }\n  return definition?.annotations?.find(\n    annotation => annotation === ASSESSMENT_WORKFLOW_TYPE,\n  )\n    ? WorkflowCategory.ASSESSMENT\n    : WorkflowCategory.INFRASTRUCTURE;\n}\n\nfunction removeProperty<T>(obj: T, propToDelete: string): T {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(item => removeProperty(item, propToDelete)) as T;\n  }\n\n  const newObj: any = {};\n\n  for (const key in obj) {\n    if (key !== propToDelete) {\n      newObj[key] = removeProperty(obj[key], propToDelete); // Recurse into nested objects\n    }\n  }\n\n  return newObj;\n}\n\nexport function parseWorkflowVariables(variables?: object): object | undefined {\n  if (variables === undefined) {\n    return undefined;\n  }\n\n  if (typeof variables === 'string') {\n    try {\n      return JSON.parse(variables);\n    } catch {\n      throw new Error(\n        `Error when parsing process instance variables: ${variables}`,\n      );\n    }\n  }\n\n  return variables;\n}\n\nexport function extractWorkflowFormat(source: string): WorkflowFormat {\n  try {\n    JSON.parse(source);\n    return 'json';\n  } catch (_) {\n    return 'yaml';\n  }\n}\n"],"names":["Specification","dump","WorkflowCategory","ASSESSMENT_WORKFLOW_TYPE"],"mappings":"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"}